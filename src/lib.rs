const MIME_BASE32_RANK: [u8; 256] = [
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
    0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
    0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
];

fn decode_step(text_in: &str, save: &mut u64, state: &mut i32, out_buffer: &mut Vec<u8>) {
    let mut last: [u8; 6] = [0x00; 6];

    if *state < 0 {
        *state = -(*state);
        last[0] = b'=';
    }

    for i in text_in.bytes() {
        let rank = MIME_BASE32_RANK[i as usize];

        if rank != 0xff {
            last[5] = last[4];
            last[4] = last[3];
            last[3] = last[2];
            last[2] = last[1];
            last[1] = last[0];
            last[0] = i;
            *save = (*save << 5) | (rank as u64);
            *state = *state + 1;
            if *state == 8 {
                out_buffer.push((*save >> 32) as u8);
                if last[5] != ('=' as u8) {
                    out_buffer.push((*save >> 24) as u8);
                }
                if last[3] != ('=' as u8) {
                    out_buffer.push((*save >> 16) as u8);
                }
                if last[2] != ('=' as u8) {
                    out_buffer.push((*save >> 8) as u8);
                }
                if last[0] != ('=' as u8) {
                    out_buffer.push((*save) as u8);
                }
                *state = 0;
            }
        }
    }
    *save = (*state) as u64;
    // if last[0] == ('=' as u8) {
    //     *state = -(i as i8) as i32;
    // } else {
    //     *state = i as i32;
    // }
}

pub fn decode(text: &str) -> Result<Vec<u8>, &'static str> {
    let mut out_buffer: Vec<u8> = Vec::new();
    let mut save: u64 = 0;
    let mut state: i32 = 0;

    decode_step(text, &mut save, &mut state, &mut out_buffer);

    Ok(out_buffer)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn do_decode_1() {
        assert_eq!(decode("MZXW6===").unwrap(), b"foo");
    }
    #[test]
    fn do_decode_2() {
        assert_eq!(decode("MZXW6YTBOI======").unwrap(), b"foobar");
    }
    #[test]
    fn do_decode_3() {
        assert_eq!(decode("MZXW6YQ=").unwrap(), b"foob");
    }
    #[test]
    fn do_decode_4() {
        let _ = decode("MZXW6===").unwrap();
        let _ = decode("MZXW6YQ=").unwrap();
        let _ = decode("MZXW6YTBOI======").unwrap();
        assert_eq!(decode("MZXW6===").unwrap(), b"foo");
        assert_eq!(decode("MZXW6YQ=").unwrap(), b"foob");
        assert_eq!(decode("MZXW6YTBOI======").unwrap(), b"foobar");
    }
}
